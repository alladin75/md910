#define uchar   unsigned char 
#define uint   unsigned int

#include <avr/io.h>
#include <avr/pgmspace.h>

const static byte CP1251Font[] PROGMEM =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E, 
  0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E, 0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 
  0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x7C, 0x38, 0x7C, 
  0x10, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 
  0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00, 
  0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78, 
  0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0, 
  0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0, 0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99, 
  0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00, 0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00, 
  0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00, 
  0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00, 0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0xCC, 0x78, 
  0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF, 
  0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 
  0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, 
  0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00, 
  0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xF0, 0xF0, 0x60, 0x60, 0x00, 0x60, 0x00, 
  0xD8, 0xD8, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0x6C, 0x6C, 0xFE, 0x6C, 0x00, 0x00, 
  0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00, 0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00, 
  0x38, 0x6C, 0x38, 0x6E, 0xDC, 0xCC, 0x76, 0x00, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x30, 0x60, 0xC0, 0xC0, 0xC0, 0x60, 0x30, 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00, 
  0x00, 0xCC, 0x78, 0xFC, 0x78, 0xCC, 0x00, 0x00, 0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 
  0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, 
  0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00, 0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00, 
  0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00, 0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00, 
  0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00, 0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00, 
  0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00, 
  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60, 
  0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xFC, 0x00, 0x00, 
  0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00, 
  0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, 0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00, 
  0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, 
  0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00, 
  0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00, 
  0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 
  0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, 
  0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00, 
  0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 
  0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00, 
  0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00, 0x78, 0xCC, 0xE0, 0x70, 0x1C, 0xCC, 0x78, 0x00, 
  0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00, 
  0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, 
  0xC6, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00, 
  0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00, 
  0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00, 
  0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 
  0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00, 
  0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 
  0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 
  0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
  0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00, 
  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00, 
  0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 
  0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E, 
  0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00, 
  0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 
  0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00, 
  0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 
  0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00, 0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00, 
  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, 0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00, 
  0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00, 
  0x1E, 0x36, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 0x7C, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C, 0x00, 
  0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 
  0x38, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0xFE, 0xC6, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00, 
  0xDB, 0xDB, 0x7E, 0x3C, 0x7E, 0xDB, 0xDB, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 
  0x66, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x66, 0x00, 0x3C, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x66, 0x00, 
  0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00, 0x1E, 0x36, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 
  0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00, 
  0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 
  0x7E, 0x81, 0xA5, 0x81, 0xA5, 0x99, 0x81, 0x7E, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00, 
  0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00, 
  0x7E, 0xDB, 0xDB, 0xDB, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x38, 0x7C, 0x7C, 0x7C, 0x38, 0x00, 0x00, 
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7F, 0x03, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
  0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xFF, 0x00, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xFF, 0x03, 
  0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C, 0x00, 0xC6, 0xC6, 0xC6, 0xF6, 0xDE, 0xDE, 0xF6, 0x00, 
  0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C, 0x00, 0x78, 0x8C, 0x06, 0x3E, 0x06, 0x8C, 0x78, 0x00, 
  0xCE, 0xDB, 0xDB, 0xFB, 0xDB, 0xDB, 0xCE, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x00, 
  0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 0x00, 0x3C, 0x60, 0x3C, 0x66, 0x66, 0x3C, 0x00, 
  0x00, 0x00, 0x7C, 0x66, 0x7C, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x60, 0x00, 
  0x00, 0x00, 0x3C, 0x6C, 0x6C, 0x6C, 0xFE, 0xC6, 0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00, 
  0x00, 0x00, 0xDB, 0x7E, 0x3C, 0x7E, 0xDB, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x0C, 0x66, 0x3C, 0x00, 
  0x7E, 0x60, 0x60, 0x7E, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x18, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x00, 
  0x00, 0x00, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00, 0x00, 0x00, 0x1E, 0x36, 0x66, 0x66, 0x66, 0x00, 
  0x00, 0x00, 0xC6, 0xFE, 0xFE, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 
  0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 
  0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 
  0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 
  0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 0x36, 
  0x24, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00, 0x8E, 0x88, 0xC8, 0xA8, 0x98, 0x88, 0x88, 0x00, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 
  0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00, 0x00, 
  0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18, 0x18, 
  0x1E, 0x36, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 0x7C, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C, 0x00, 
  0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 
  0x38, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0xFE, 0xC6, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00, 
  0xDB, 0xDB, 0x7E, 0x3C, 0x7E, 0xDB, 0xDB, 0x00, 0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00, 
  0x66, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x66, 0x00, 0x3C, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x66, 0x00, 
  0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00, 0x1E, 0x36, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 
  0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00, 
  0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 
  0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00, 
  0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00, 
  0x7E, 0xDB, 0xDB, 0xDB, 0x7E, 0x18, 0x18, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00, 
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7F, 0x03, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x06, 0x00, 
  0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xFF, 0x00, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xFF, 0x03, 
  0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C, 0x00, 0xC6, 0xC6, 0xC6, 0xF6, 0xDE, 0xDE, 0xF6, 0x00, 
  0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C, 0x00, 0x78, 0x8C, 0x06, 0x3E, 0x06, 0x8C, 0x78, 0x00, 
  0xCE, 0xDB, 0xDB, 0xFB, 0xDB, 0xDB, 0xCE, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x00, 
  0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 0x00, 0x3C, 0x60, 0x3C, 0x66, 0x66, 0x3C, 0x00, 
  0x00, 0x00, 0x7C, 0x66, 0x7C, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x60, 0x00, 
  0x00, 0x00, 0x3C, 0x6C, 0x6C, 0x6C, 0xFE, 0xC6, 0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00, 
  0x00, 0x00, 0xDB, 0x7E, 0x3C, 0x7E, 0xDB, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x0C, 0x66, 0x3C, 0x00, 
  0x00, 0x00, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x00, 0x00, 0x18, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x00, 
  0x00, 0x00, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00, 0x00, 0x00, 0x1E, 0x36, 0x66, 0x66, 0x66, 0x00, 
  0x00, 0x00, 0xC6, 0xFE, 0xFE, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 
  0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 
  0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00, 
  0x00, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3E, 0x06, 0x3C, 0x00, 
  0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x18, 0x00, 0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00, 
  0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7F, 0x03, 0x00, 0x00, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x00, 
  0x00, 0x00, 0xDB, 0xDB, 0xDB, 0xDB, 0xFF, 0x00, 0x00, 0x00, 0xDB, 0xDB, 0xDB, 0xDB, 0xFF, 0x03, 
  0x00, 0x00, 0xE0, 0x60, 0x7C, 0x66, 0x7C, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xF6, 0xDE, 0xF6, 0x00, 
  0x00, 0x00, 0x60, 0x60, 0x7C, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x7C, 0x06, 0x3E, 0x06, 0x7C, 0x00, 
  0x00, 0x00, 0xCE, 0xDB, 0xFB, 0xDB, 0xCE, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x3E, 0x36, 0x66, 0x00
};

#define b1stHead_D    8
#define b1stHead_B    9
#define b1stHead_A    10
#define b1stHead_C    11

#define b2ndHead_H    4
#define b2ndHead_F    5
#define b2ndHead_E    6
#define b2ndHead_G    7

#define Motor         13
#define Feed          12
#define DotPulse      3
#define ResetPulse    2

word DP_Count;

// буфер для рендеринга строки
// состоит из 144 байтов (72 столбца * 2 печатающие головки)
// данные отправляются сначала старшие 4 бита - для первого прохода, потом младшие 4 бита
byte MD910_Buffer[]=
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
};


void setup()
{                
  // устанавливаем выходные пины и подтягиваем их к "0"
  pinMode(b1stHead_D, OUTPUT);
  digitalWrite(b1stHead_D, LOW);
  pinMode(b1stHead_B, OUTPUT);
  digitalWrite(b1stHead_B, LOW);
  pinMode(b1stHead_A, OUTPUT);
  digitalWrite(b1stHead_A, LOW);
  pinMode(b1stHead_C, OUTPUT);
  digitalWrite(b1stHead_C, LOW);

  pinMode(b2ndHead_H, OUTPUT);
  digitalWrite(b2ndHead_H, LOW);
  pinMode(b2ndHead_F, OUTPUT);
  digitalWrite(b2ndHead_F, LOW);
  pinMode(b2ndHead_E, OUTPUT);
  digitalWrite(b2ndHead_E, LOW);
  pinMode(b2ndHead_G, OUTPUT);
  digitalWrite(b2ndHead_G, LOW);

  pinMode(Motor, OUTPUT);
  digitalWrite(Motor, LOW);

  pinMode(Feed, OUTPUT);
  digitalWrite(Feed, LOW);

  pinMode(DotPulse, INPUT);
  digitalWrite(DotPulse, LOW);

  pinMode(ResetPulse, INPUT);
  digitalWrite(ResetPulse, LOW);

  Serial.begin(9600); 
  while (!Serial) {
  };
  delay(100);
  Serial.println("Init done !");
}

boolean RP_Status()          // функция возвращает: датчик разомкнут = false, замкнут = true
{                            // вход ардуино подтянут резистором 4,7к к плюсу питания,
  boolean funcResult;        // поэтому при замыкании датчика на входе ардуино появляется 0
  funcResult=! digitalRead(ResetPulse); // инвертируем, поскольку у меня датчики дают инвертированные показания
  return funcResult;
};

boolean DP_Status()          // датчик разомкнут = false, замкнут = true
{
  boolean funcResult;
  funcResult=! digitalRead(DotPulse); // инвертируем, поскольку у меня датчики дают инвертированные показания
  return funcResult;
};


void MD910_Init()
{
  digitalWrite(Motor, HIGH); // включаем мотор
  DP_Count=0;

  if (RP_Status()==false)             
  {                                    // если датчик начального положения печатающей головки разомкнут то
    while (RP_Status()==false) {
    };     // ждем пока не замкнется датчик начального положения печатающей головки
    while (RP_Status()==true) {
    };      // теперь ждем пока не разомкнется датчик начального положения печатающей головки
    DP_Count=1;                        // вот теперь это начальное положение
  }
  else
  {
    while (RP_Status()==true) {
    };      // в этой ситуации ждем пока не разомкнется датчик начального положения печатающей головки
    DP_Count=1;
  };

  Serial.println("MD910_Init Done !");

};

void PrintBuffer2Serial()
{
  Serial.println("Render Buffer:");
  for(byte j=0;j<=143;j++)
  {
    Serial.print(MD910_Buffer[j], HEX);
    Serial.print(" , ");
  };
  Serial.println("");
}


// FontData=pgm_read_byte(&(CP1251Font[Address]));
// https://www.arduino.cc/reference/en/language/variables/utilities/progmem/
// к сожалению оперативная память всего 1К поэтому фонт размещен в программной памяти 
// http://www.nongnu.org/avr-libc/user-manual/pgmspace.html

// длина печатаемой строки 18 символов (144 / 8) +1 байт на символ конца строки = 19 байт
void MD910_RenderPrintStr(char String2Print[19]) 
{ 
  byte TmpVal[8], MaskBit[8];
  byte i,j,k, Code, Column, Value;
  word FontStart;
  
//***************************************************************
  Column=0;                 // индекс на MD910_Buffer[]
  for(j=0;j<=17;j++)        // отрабатываем каждый символ
  { 

    Code=byte(String2Print[j]);
    FontStart=Code*8;       // индекс, указывающий на начало данных шрифта в CP1251Font[]
    for (k=0; k<=7; k++)
      {
        TmpVal[k]=pgm_read_byte(&(CP1251Font[FontStart+k]));
      };

    for(i=0;i<=7;i++)       
    { 
      for (k=0; k<=7; k++)
        {
          MaskBit[k]=(TmpVal[k] & 128) >> k;
        };
        
      Value=0;
      
      for (k=0; k<=7; k++)
       {
         Value=(Value | MaskBit[k]);
       };
      
      MD910_Buffer[Column]=Value;
      
      for (k=0; k<=7; k++)
       {
        TmpVal[k]=TmpVal[k] << 1;
       };
      
      Column++; // переходим к обработке следующей колонке
    };
  };  
//***************************************************************
};

void WaitDotPulses(word Counts)
{
  word InternalCounter;
  InternalCounter=0;
  while (InternalCounter<Counts)
  {
    while (DP_Status()==true) {};
    while (DP_Status()==false) {};
    DP_Count++; InternalCounter++;
  }
}



void MD910_PrintBuffer()
{
  byte PinA, PinB, PinC, PinD, PinE, PinF, PinG, PinH;
  Serial.println("Printing....");
//***********************************************************************************************************
  DP_Count=0;

// печатаем верхнюю часть строки ***************************
  if (RP_Status()==false)
  {
    for(byte j=0;j<=71;j++)
    {

      PinA=MD910_Buffer[j] & 0x80;
      PinB=MD910_Buffer[j] & 0x40;
      PinC=MD910_Buffer[j] & 0x20;
      PinD=MD910_Buffer[j] & 0x10;

      PinE=MD910_Buffer[j+72] & 0x80;
      PinF=MD910_Buffer[j+72] & 0x40;
      PinG=MD910_Buffer[j+72] & 0x20;
      PinH=MD910_Buffer[j+72] & 0x10;

      // 1 такт
      // можно включать точки A,C и E,G (нечетные)
      if (PinA>0) digitalWrite(b1stHead_A, HIGH);    // 
      if (PinC>0) digitalWrite(b1stHead_C, HIGH);    // 
      if (PinE>0) digitalWrite(b2ndHead_E, HIGH);    //
      if (PinG>0) digitalWrite(b2ndHead_G, HIGH);    //

      while (DP_Status()==true) {};
      while (DP_Status()==false) {};
      DP_Count++;

      digitalWrite(b1stHead_A, LOW);
      digitalWrite(b1stHead_C, LOW);
      digitalWrite(b2ndHead_E, LOW);
      digitalWrite(b2ndHead_G, LOW);

      while (DP_Status()==true) {};
      while (DP_Status()==false) {};
      DP_Count++;

      // 2 такт
      // можно включать точки B,D и F,H (четные)
      
      if (PinB>0) digitalWrite(b1stHead_B, HIGH);    // 
      if (PinD>0) digitalWrite(b1stHead_D, HIGH);    // 
      if (PinF>0) digitalWrite(b2ndHead_F, HIGH);    //
      if (PinH>0) digitalWrite(b2ndHead_H, HIGH);    //

      while (DP_Status()==true) {
      };
      while (DP_Status()==false) {
      };
      DP_Count++;

      digitalWrite(b1stHead_B, LOW);
      digitalWrite(b1stHead_D, LOW);
      digitalWrite(b2ndHead_F, LOW);
      digitalWrite(b2ndHead_H, LOW);

      while (DP_Status()==true) {};
      while (DP_Status()==false) {};
      DP_Count++;
      
    };
  }

  while (RP_Status()==false) {}; // ждем когда головка переместится в начало
  while (RP_Status()==true) {};  // теперь ждем когда головка переместится в начало области печати

// печатаем нижнюю часть строки ***************************

  if (RP_Status()==false)
  {
    for(byte j=0;j<=71;j++)
    {

      PinA=MD910_Buffer[j] & 0x08;
      PinB=MD910_Buffer[j] & 0x04;
      PinC=MD910_Buffer[j] & 0x02;
      PinD=MD910_Buffer[j] & 0x01;

      PinE=MD910_Buffer[j+72] & 0x08;
      PinF=MD910_Buffer[j+72] & 0x04;
      PinG=MD910_Buffer[j+72] & 0x02;
      PinH=MD910_Buffer[j+72] & 0x01;

      // 1 такт
      // можно включать точки A,C и E,G (нечетные)
      if (PinA>0) digitalWrite(b1stHead_A, HIGH);    // 
      if (PinC>0) digitalWrite(b1stHead_C, HIGH);    // 
      if (PinE>0) digitalWrite(b2ndHead_E, HIGH);    //
      if (PinG>0) digitalWrite(b2ndHead_G, HIGH);    //

      while (DP_Status()==true) {};
      while (DP_Status()==false) {};
      DP_Count++;

      digitalWrite(b1stHead_A, LOW);
      digitalWrite(b1stHead_C, LOW);
      digitalWrite(b2ndHead_E, LOW);
      digitalWrite(b2ndHead_G, LOW);

      while (DP_Status()==true) {};
      while (DP_Status()==false) {};
      DP_Count++;
      

      // 2 такт
      // можно включать точки B,D и F,H (четные)
      
      if (PinB>0) digitalWrite(b1stHead_B, HIGH);    // 
      if (PinD>0) digitalWrite(b1stHead_D, HIGH);    // 
      if (PinF>0) digitalWrite(b2ndHead_F, HIGH);    //
      if (PinH>0) digitalWrite(b2ndHead_H, HIGH);    //

      while (DP_Status()==true) {
      };
      while (DP_Status()==false) {
      };
      DP_Count++;

      digitalWrite(b1stHead_B, LOW);
      digitalWrite(b1stHead_D, LOW);
      digitalWrite(b2ndHead_F, LOW);
      digitalWrite(b2ndHead_H, LOW);

      while (DP_Status()==true) {};
      while (DP_Status()==false) {};
      DP_Count++;
      
    };
  }
 while (RP_Status()==false) {};
 while (RP_Status()==true) {};

//***********************************************************************************************************
  Serial.println("Done !");
}


void loop() 
{
  MD910_RenderPrintStr("** CitizenMD910 **");
  MD910_Init();
  MD910_PrintBuffer();
  delay(50);
  MD910_RenderPrintStr("-- PrintingDemo --");
  MD910_Init();
  MD910_PrintBuffer();
  delay(50);
  MD910_RenderPrintStr("geektimes.ru/users");
  MD910_Init();
  MD910_PrintBuffer();
  delay(50);
  MD910_RenderPrintStr("    /BaurzhanD/   ");
  MD910_Init();
  MD910_PrintBuffer();
  delay(50);
  MD910_RenderPrintStr("    Uralsk, KZ    ");
  MD910_Init();
  MD910_PrintBuffer();
  delay(50);

  delay(300);
  digitalWrite(Motor, LOW);
  PrintBuffer2Serial();
  while (1>0) {
  };
}

/*
MD910_CountDP();
 MD910_PrintDemo();
 MD910_PrintDemo();
 */


//  MD910_PrintDemo();
//  digitalWrite(Motor, LOW);

/*
void MD910_CountDP()                    // процедура для подсчета тактов DotPulse до замыкания и после замыкания
{                                       // контактов ResetPulse 
  byte DP_AfterRP;

  DP_AfterRP=0;
  while (RP_Status()==false)            // будем считать количество тактов DotPulse пока не замкнуты контакты ResetPulse
  {
    while (DP_Status()==true) {
    };
    while (DP_Status()==false) {
    };
    DP_Count++;
  };

  while (RP_Status()==true)             // будем считать количество тактов DotPulse с момента замыкания контактов ResetPulse       
  {
    while (DP_Status()==true) {
    };
    while (DP_Status()==false) {
    };
    DP_AfterRP++;
  };

  Serial.print("DP before RP ="); 
  Serial.println(DP_Count, DEC);
  Serial.print("DP after RP ="); 
  Serial.println(DP_AfterRP, DEC);

  DP_Count=1;
};



void MD910_PrintDemo()
{
  DP_Count=0;
  if (RP_Status()==false)
  {
    for(byte j=1;j<=144;j++)
    {
      // 1 такт
      // можно включать точки A,C и E,G (нечетные)
      digitalWrite(b1stHead_A, HIGH);    // 
      digitalWrite(b1stHead_C, HIGH);    // 
      digitalWrite(b2ndHead_E, HIGH);    //
      digitalWrite(b2ndHead_G, HIGH);    //

      while (DP_Status()==true) {
      };
      while (DP_Status()==false) {
      };
      DP_Count++;

      digitalWrite(b1stHead_A, LOW);
      digitalWrite(b1stHead_C, LOW);
      digitalWrite(b2ndHead_E, LOW);
      digitalWrite(b2ndHead_G, LOW);

      // 2 такт
      // можно включать точки B,D и F,H (четные)
      digitalWrite(b1stHead_B, HIGH);    // 
      digitalWrite(b1stHead_D, HIGH);    // 
      digitalWrite(b2ndHead_F, HIGH);    //
      digitalWrite(b2ndHead_H, HIGH);    //

      while (DP_Status()==true) {
      };
      while (DP_Status()==false) {
      };
      DP_Count++;

      digitalWrite(b1stHead_B, LOW);
      digitalWrite(b1stHead_D, LOW);
      digitalWrite(b2ndHead_F, LOW);
      digitalWrite(b2ndHead_H, LOW);
    };
  }

  while (RP_Status()==false) {
  }; // ждем когда головка переместится в начало
  while (RP_Status()==true) {
  };  // теперь ждем когда головка переместится в начало области печати
};

void PrintFontTable()
{
  byte Value;
  for (word i=0;i<=255;i++)
  {
    Serial.print(i*8, HEX);
    Serial.print(" :");
    for (byte j=0; j<=7; j++)
    {
      Value=pgm_read_byte(&(CP1251Font[i*8+j]));
      Serial.print(Value, HEX);
      Serial.print(" , ");
    };
    Serial.println("");
  }
  Serial.println("");
}


void MD910_WaitPrintPos()
{
  while (DP_Count<=72)
  {
    if (DP_Status()==true)
    {
      while (DP_Status()==true) {
      };
      while (DP_Status()==false) {
      };  
    }
    else
    {
    }


    while (DP_Status()==true) {
    };
    while (DP_Status()==false) {
    };  
  }  
}






      PinA=MD910_Buffer[j] & 0x08;
      PinB=MD910_Buffer[j] & 0x04;
      PinC=MD910_Buffer[j] & 0x02;
      PinD=MD910_Buffer[j] & 0x01;

      PinE=MD910_Buffer[j+72] & 0x08;
      PinF=MD910_Buffer[j+72] & 0x04;
      PinG=MD910_Buffer[j+72] & 0x02;
      PinH=MD910_Buffer[j+72] & 0x01;
********************************************************************************************************

*/

















